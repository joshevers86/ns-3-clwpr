
@node Frame Reception Process
@section Frame Reception Process

The frame reception process is divided into 4 events within @code{PhySimWifiPhy}, see @ref{fig:physim-reception}: the initial @code{PhySimWifiPhy::StartReceive} 
event that indicates that the first complex time sample has propagated through the channel and has arrived at the receiver, the @code{PhySimWifiPhy::EndPreamble} 
event, that indicates that all complex time samples that represent the frame preamble with all of its training symbols have arrived at the receiver, the 
@code{PhySimWifiPhy::EndHeader} event which expires once all complex time samples that represent the signal header have arrived, and finally the 
@code{PhySimWifiPhy::EndRx} event, which indicates when the whole frame has finally arrived. 

@float Figure,fig:physim-reception
@caption{The frame reception process and its division into four distinct events.}
@center @image{figures/figure4-reception, 5in}
@end float

At @code{PhySimWifiPhy::StartReceive}, the packet is added to @code{PhySimInterferenceHelper} in order to keep track of the interference added by the
arriving packet. Further, depending on the current PHY state, that is only if the physical layer is currently in @code{IDLE} or @code{CCA_BUSY} state, a new 
@code{PhySimWifiPhy::EndPreamble} event is scheduled and it is checked whether a new @code{CCA_BUSY} phase has to be started (e.g. because the cumulative signal 
energy at the received now exceeds the configured CcaBusyThreshold).

At @code{PhySimWifiPhy::EndPreamble}, the @code{PhySimSignalDetector} module is used to check whether the repeating pattern of the short training symbols can
be detected or not. If it can be detected and if the signal-to-interference noise ratio (SINR) is greater than zero and if the physical layer is either in 
@code{CCA_BUSY}, @code{IDLE} or @code{SYNC} state, it is then assumed that the receiver can lock on to that frame. Then the receiver performs time synchronization 
based on the long training symbols using the @code{PhySimSignalDetector} module. An initial channel estimation also takes place through the @code{PhySimChannelEstimator} module.
 Afterwards, a @code{PhySimWifiPhy::Endheader} event is scheduled and the physical layer state is changed to @code{SYNC}. 

Note that for all events the cumulative time samples of all arriving packets are used as input for the signal processing. Further, the input for the 
signal detection mechanism contains more than the 320 samples that reflect the short and long training symbols. In particular, 2 microseconds before and after
the exact start and ending time of the preamble are added, in order to challenge the signal detection algorithm and reflect real-system conditions.  

At @code{PhySimWifiPhy::EndHeader}, the initial channel estimate is applied to all time samples. Afterwards, the header is decoded by applying the reverse signal
processing steps of the frame construction process. The result is a bit vector that contains the SIGNAL header of the packet. The header is then examined to determine
the modulation and coding rate used for the rest of the frame, the frame length, and the parity bit. Only if all values in the header are plausible, and the physical
layer is currently either in @code{IDLE}, @code{CCA_BUSY} or @code{SYNC} state, a @code{PhySimWifiPhy::EndRx} event is scheduled after the expected end of the 
packet. In addition, all still running @code{EndPreamble} and @code{EndHeader} events are canceled, and the physical layer state is changed to @code{RX}.

At @code{PhySimWifiPhy::EndRx}, the data symbols are decoded. Again, the initial channel estimate is applied to all time samples. Afterwards, the OFDM and the 
bit modulation are reversed and the forward error correction bits are used to correct possible errors. Then, the initial state of the scrambler at the transmitter 
is recovered and used to re-arrange the bits into their original order. And if the decoded data bits are identical to the transmitted data bits in the end, the
reception is considered to be successful, and the physical layer state is changed either to @code{IDLE} or @code{CCA_BUSY}, depending on whether the cumulative 
signal strength is above or below the configured CcaBusyThreshold.     
